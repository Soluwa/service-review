{
  "_id": "_design/reports",
  "_rev": "1-be19393491efed8f9fd34f86fe7d7bb3",
  "views": {
    "reviewById": {
      "map": " function (doc) {\n  var conversation = { id: doc._id, \n    turns: [], \n    configId: doc.configId, \n    brand: doc.brand,\n    channel: doc.channel,\n    startTime: doc.firstTurn,\n    latestTime: doc.latestTurn };\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n    var turn = doc.turns[i];\n    var outputTurn = { classifications: {}, entities: {}, custom: [], nodes: [] };\n    \n    // classifications \n    // grouped by modelref only one utterance\n    if (turn.question.utterances[0]\n      && turn.question.utterances[0].classifications) {\n        for (var z = 0; z < turn.question.utterances[0].classifications.length; z += 1) {\n          var classification = turn.question.utterances[0].classifications[z]; \n          if (!outputTurn.classifications[classification.modelRef]) {\n            outputTurn.classifications[classification.modelRef] = {};\n          }\n          \n          outputTurn.classifications[classification.modelRef][classification.value] = classification.confidence;\n        }\n    }\n    \n    // entities\n    // grouped by modelref only one utterance\n    if (turn.question.utterances[0]\n      && turn.question.utterances[0].entities) {\n        for (var z = 0; z < turn.question.utterances[0].entities.length; z += 1) {\n          var entity = turn.question.utterances[0].entities[z]; \n          if(!outputTurn.entities[entity.modelRef]) {\n            outputTurn.entities[entity.modelRef] = {};\n          }\n          \n          outputTurn.entities[entity.modelRef][entity.entity] = entity.value;\n        }\n    }\n    \n    // close\n    if (turn.state.closed \n      && turn.state.closeReason) {\n      outputTurn.closeReason = turn.state.closeReason;\n    }\n    \n    // escalation\n    if (!turn.state.escalated \n      && turn.state.escalationTarget) {\n        outputTurn.escalationTarget = turn.state.escalationTarget;\n    }\n    \n    // nodes\n    if (turn.events) {\n      for (var p = 0; p < turn.events.length; p += 1) {\n        if (turn.events[p].type === 'customDialogEvent') {\n          outputTurn.custom.push({\n            name: turn.events[p].name,\n            model: turn.events[p].nodel,\n            value: turn.events[p].nodeHead\n          });\n        }\n        \n        if (turn.events[p].type === 'nodeVisited' \n          && turn.events[p].nodeLname) {\n          outputTurn.nodes.push({\n            name: turn.events[p].nodeLname,\n            model: turn.events[p].model\n          });\n        }\n      }\n    }\n    conversation.turns.push(outputTurn);\n  }\n  \n   emit(doc._id, conversation);\n}"
    },
    "reviewByFirstDate": {
      "map": " function (doc) {\n  var conversation = { id: doc._id, \n    turns: [], \n    configId: doc.configId, \n    brand: doc.brand,\n    channel: doc.channel,\n    startTime: doc.firstTurn,\n    latestTime: doc.latestTurn };\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n    var turn = doc.turns[i];\n    var outputTurn = { classifications: {}, entities: {}, custom: [], nodes: [] };\n    \n    // classifications \n    // grouped by modelref only one utterance\n    if (turn.question.utterances[0]\n      && turn.question.utterances[0].classifications) {\n        for (var z = 0; z < turn.question.utterances[0].classifications.length; z += 1) {\n          var classification = turn.question.utterances[0].classifications[z]; \n          if (!outputTurn.classifications[classification.modelRef]) {\n            outputTurn.classifications[classification.modelRef] = {};\n          }\n          \n          outputTurn.classifications[classification.modelRef][classification.value] = classification.confidence;\n        }\n    }\n    \n    // entities\n    // grouped by modelref only one utterance\n    if (turn.question.utterances[0]\n      && turn.question.utterances[0].entities) {\n        for (var z = 0; z < turn.question.utterances[0].entities.length; z += 1) {\n          var entity = turn.question.utterances[0].entities[z]; \n          if(!outputTurn.entities[entity.modelRef]) {\n            outputTurn.entities[entity.modelRef] = {};\n          }\n          \n          outputTurn.entities[entity.modelRef][entity.entity] = entity.value;\n        }\n    }\n    \n    // close\n    if (turn.state.closed \n      && turn.state.closeReason) {\n      outputTurn.closeReason = turn.state.closeReason;\n    }\n    \n    // escalation\n    if (!turn.state.escalated \n      && turn.state.escalationTarget) {\n        outputTurn.escalationTarget = turn.state.escalationTarget;\n    }\n    \n    // nodes\n    if (turn.events) {\n      for (var p = 0; p < turn.events.length; p += 1) {\n        if (turn.events[p].type === 'customDialogEvent') {\n          outputTurn.custom.push({\n            name: turn.events[p].name,\n            model: turn.events[p].nodel,\n            value: turn.events[p].nodeHead\n          });\n        }\n        \n        if (turn.events[p].type === 'nodeVisited' \n          && turn.events[p].nodeLname) {\n          outputTurn.nodes.push({\n            name: turn.events[p].nodeLname,\n            model: turn.events[p].model\n          });\n        }\n      }\n    }\n    conversation.turns.push(outputTurn);\n  }\n  \n   emit(doc.firstTurn, conversation);\n}"
    },
    "tableauByConvId": {
      "map": "function (doc) {\n  var conversation = { id: doc._id, \n    configId: doc.configId, \n    brand: doc.brand,\n    channel: doc.channel,\n    startTime: doc.firstTurn,\n    latestTime: doc.latestTurn };\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n      var turn = doc.turns[i];\n      // close\n    if (turn.state.closed \n      && turn.state.closeReason) {\n      conversation.closeReason = turn.state.closeReason;\n    }\n    \n        // escalation\n    if (!turn.state.escalated \n      && turn.state.escalationTarget) {\n        conversation.escalationTarget = turn.state.escalationTarget;\n    }\n    \n    // events\n    if (turn.events) {\n      for (var p = 0; p < turn.events.length; p += 1) {\n        if (turn.events[p].type === 'customDialogEvent') {\n          if (turn.events[p].name === 'IntRec') {\n            if (!conversation.IntRec) {\n              conversation.IntRec = turn.events[p].value;\n              for (var z = 0; z < turn.question.utterances[0].classifications.length; z += 1) {\n                var classification = turn.question.utterances[0].classifications[z]; \n                if (classification.intent.toLowerCase() === turn.events[p].value.toLowerCase()) {\n                  conversation.confidence = classification.confidence;\n                }\n              }\n            }\n          } else {\n            conversation[turn.events[p].name] =  (turn.events[p].value) ? turn.events[p].value : 1;\n          }\n        }\n      }\n    }\n  }\n  \n  emit(doc._id, conversation);\n}"
    },
    "tableauByDate": {
      "map": "function (doc) {\n  var conversation = { id: doc._id, \n    configId: doc.configId, \n    brand: doc.brand,\n    channel: doc.channel,\n    startTime: doc.firstTurn,\n    latestTime: doc.latestTurn };\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n      var turn = doc.turns[i];\n      // close\n    if (turn.state.closed \n      && turn.state.closeReason) {\n      conversation.closeReason = turn.state.closeReason;\n    }\n    \n        // escalation\n    if (!turn.state.escalated \n      && turn.state.escalationTarget) {\n        conversation.escalationTarget = turn.state.escalationTarget;\n    }\n    \n    // events\n    if (turn.events) {\n      for (var p = 0; p < turn.events.length; p += 1) {\n        if (turn.events[p].type === 'customDialogEvent') {\n          if (turn.events[p].name === 'IntRec') {\n            if (!conversation.IntRec) {\n              conversation.IntRec = turn.events[p].value;\n              for (var z = 0; z < turn.question.utterances[0].classifications.length; z += 1) {\n                var classification = turn.question.utterances[0].classifications[z]; \n                if (classification.intent.toLowerCase() === turn.events[p].value.toLowerCase()) {\n                  conversation.confidence = classification.confidence;\n                }\n              }\n            }\n          } else {\n            conversation[turn.events[p].name] =  (turn.events[p].value) ? turn.events[p].value : 1;\n          }\n        }\n      }\n    }\n  }\n  \n  emit(doc.firstTurn, conversation);\n}"
    },
    "events": {
      "map": "function (doc) {\n  var conversation = { };\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n      var turn = doc.turns[i];\n    \n    // events\n    if (turn.events) {\n      for (var p = 0; p < turn.events.length; p += 1) {\n        if (turn.events[p].type === 'customDialogEvent') {\n          conversation[turn.events[p].name] = \"\";\n        }\n      }\n    }\n  }\n  \n  var tdt = new Date(doc.firstTurn);\n  var dayn = (tdt.getDay() + 6) % 7;\n  tdt.setDate(tdt.getDate() - dayn + 3);\n  var firstThursday = tdt.valueOf();\n  tdt.setMonth(0, 1);\n  if (tdt.getDay() !== 4) {\n    tdt.setMonth(0, 1 + ((4 - tdt.getDay()) + 7) % 7);\n  }\n  \n  var week =  1 + Math.ceil((firstThursday - tdt) / 604800000);\n\n  var dates = doc.firstTurn.split('T')[0].split('-');\n  emit([dates[0],week,conversation], 1);\n}",
      "reduce": "_sum"
    },
    "intents": {
      "map": "function (doc) {\n  var intent = \"Unknown\";\n  \n  // loop through each turn\n  for (var i = 0; i < doc.turns.length; i += 1) {\n      var turn = doc.turns[i];\n    \n    // events\n    if (turn.events && intent === \"Unknown\") {\n      for (var p = 0; p < turn.events.length; p += 1) {\n         if (turn.events[p].name === 'IntRec') {\n          intent = turn.events[p].value;\n        }\n      }\n    }\n  }\n  \n  var tdt = new Date(doc.firstTurn);\n  var dayn = (tdt.getDay() + 6) % 7;\n  tdt.setDate(tdt.getDate() - dayn + 3);\n  var firstThursday = tdt.valueOf();\n  tdt.setMonth(0, 1);\n  if (tdt.getDay() !== 4) {\n    tdt.setMonth(0, 1 + ((4 - tdt.getDay()) + 7) % 7);\n  }\n  \n  var week =  1 + Math.ceil((firstThursday - tdt) / 604800000);\n\n  var dates = doc.firstTurn.split('T')[0].split('-');\n  emit([dates[0],week,intent], 1);\n}",
      "reduce": "_sum"
    }
  }
}